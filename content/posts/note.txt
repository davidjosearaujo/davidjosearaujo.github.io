+++ 
draft = true
date = 2024-11-21T15:51:16Z
title = "Everything Is A File"
description = "When you don't know what to do, just remember: _everything is a file_"
slug = ""
authors = ["David Ara√∫jo"]
tags = ["research", "forensics", "exploitation", "malware analysis", "hacking", "reverse engineering"]
categories = ["/file-system"]
externalLink = ""
series = []
+++


---
https://dev.to/eteimz/everything-is-a-file-explained-g2a
---

https://en.wikipedia.org/wiki/Unix_file_types

The seven standard Unix file types are regular, directory, symbolic link, FIFO special, block special, character special, and socket

For regular files, Unix does not impose or provide any internal file structure; therefore, their structure and interpretation is entirely dependent on the software using them.[2] However, the file command can usually be used to determine what type of data they contain.

# Directory

The most common special file is the directory.

A directory is marked with a d as the first letter in the mode field in the output of ls -dl or stat

# Symbolic link

A symbolic link is a reference to another file. This special file is stored as a textual representation of the referenced file's path (which means the destination may be a relative path, or may not exist at all).

A symbolic link is marked with an l (lower case L) as the first letter of the mode string, e.g. in this abbreviated ls -l output

# FIFO (named pipe)

One of the strengths of Unix has always been inter-process communication. Among the facilities provided by the OS are pipes, which connect the output of one process to the input of another. This is fine if both processes exist in the same parent process space, started by the same user, but there are circumstances where the communicating processes must use FIFOs, here referred to as named pipes. One such circumstance occurs when the processes must be executed under different user names and permissions.

Named pipes are special files that can exist anywhere in the file system. They can be created with the command mkfifo as in mkfifo mypipe.

A named pipe is marked with a p as the first letter of the mode string, e.g. in this abbreviated ls -l output

# Socket

A socket is a special file used for inter-process communication, which enables communication between two processes. In addition to sending data, processes can send file descriptors across a Unix domain socket connection using the sendmsg() and recvmsg() system calls.

Unlike named pipes which allow only unidirectional data flow, sockets are fully duplex-capable.

A socket is marked with an s as the first letter of the mode string

# Device file (block, character)

In Unix, almost all things are handled as files and have a location in the file system, even hardware devices like hard drives. The great exception is network devices, which do not turn up in the file system but are handled separately.

Device files are used to apply access rights to the devices and to direct operations on the files to the appropriate device drivers.

Unix makes a distinction between character devices and block devices. The distinction is roughly as follows:
- Character devices provide only a serial stream of input or accept a serial stream of output
- Block devices are randomly accessible

Although, for example, disk partitions may have both character devices that provide un-buffered random access to blocks on the partition and block devices that provide buffered random access to blocks on the partition.

A character device is marked with a c as the first letter of the mode string and a block device is marked with a b, e.g. in this abbreviated ls -l output
---

https://dev.to/chandelieraxel/what-is-a-file-in-unix-systems--m5g

In an operating system (OS), various features rely on files, including processes, devices, networks, and directories. There are 7 types of files, with regular files and directories being two of the main types. This summary will focus on regular files and directories for now.

From an operating system (OS) perspective, a file is represented as an inode, a data structure containing metadata about the file. This metadata includes information such as creation date, last update date, ownership, permissions, and file size. Note that the file name and actual file data are not part of the inode.

You can visualize an inode informations directly in your terminal, by typing the ls -l command.

In order :

- File type and permissions. It's quite hard to read, let's break it down together.
    - The first character specify the what kind of file this is (the 7 types we mentionned earlier).
        - - Regular file.
        - d Directory.
        - l Symbolic link.
        - b Block special file.
        - c Character special file.
        - s Socket link.
        - p FIFO.
    - The next three characters are related to the owner permissions for the file.
    - The next three characters are related to the group permissions for the file.
    - The last three characters are related to the others permissions for the file.

    - All permissions fields can be read as follow :
        - Is the permission allowed to read the file ? - for no, r for yes.
        - Is the permission allowed to write the file ? - for no, w for yes.
        - Is the permission allowed to execute the file ? - for no, x for yes.
- Number of hard links. You may find more informations here.
- Owner name.
- Group name.
- Number of bytes in your file.
- Date of last modification.
- File name. Not a part of the inode, but still in the output. More on it later.

If you're willing to get a bit more information about a specific file, you may want to use the stat command directly.

If you execute the ls -li command you will find an extra column at the beginning of the output.

An inode contains a unique iLPCC
Since the file name is not stored in the inode, it must be stored elsewhere. The file name is actually stored in the parent directory. A directory is simply a container that holds a list of files and subdirectories, and can be viewed using a command like ls -l.

The directories files actually only contain a mapping table, between a file inode number, and his name.

The list goes on for all the file or other directories it may contain.

A directory is nothing but a specific file, it also have an inode number, and his name is saved within his parent directory inode.

So, where is the file data ?

What make the inode so special is that it kept references (pointers) toward the memory blocks that are actually containing the data in disk. By doing so, when we ask to open the file, it go through all of them and recover the information needed.
---

https://microsoft.github.io/WhatTheHack/020-LinuxFundamentals/Student/resources/concepts.html

---

https://www.tecmint.com/everything-is-file-and-types-of-files-linux/

---

Talk about how you can access information about running processes by reading the files in /proc

First find PID of running process using top / htop, and then look for the dir with that name and read the status file inside it for more information

Also, you should read the cgroup and environ files